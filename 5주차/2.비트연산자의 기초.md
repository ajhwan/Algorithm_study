# +(플러스), -(마이너스)
- 비트연산자에 +(플러스)와 -(마이너스)는 비트연산자라고 볼 수는 없음
- 비트연산자를 활용할 때 -(마이너스)가 나오기때문에 중요

## 비트연산자 표
<img width="530" alt="스크린샷 2023-09-06 오후 7 16 37" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/fe427cd4-6487-4e2a-9389-9b50c17597fc">

## 비트연산자 +, - 예제
- 5 + 1
  - 5 + 1 = 6이고 이진수로 표현하면 101 + 1 = 110 = 6이 됨
- 5 - 1
  - 5 - 1 = 4이고 이진수로 표현하면 101 - 1 = 100 = 4가 됨
- 21 + 3
  - 21 + 3 = 24이고 이진수로 표현하면 10101 + 11 = 11000 = 24가 됨
- 10101(2) - 11(2)
  - 10101(2) - 11(2) = 10010이 되고 10진수로 표현하면 21 - 3 = 18 = 10010(2)가 됨

# &(AND), |(OR)
- &는 true & true = true (1 & 1 = 1)이고 나머지는 모두 false를 반환하는 것
> &연산자 표
<img width="283" alt="스크린샷 2023-09-06 오후 7 25 43" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/9a00be69-f462-425e-a68e-e9b972667b63">

- ex) 1001 & 1000의 값
  - 모두 1이 아닌 부분에 대해서는 0이 되므로 1000(2)가 됨

- |연산자는 하나라도 true면 모두 true가 됨
> |연산자 표
<img width="288" alt="스크린샷 2023-09-06 오후 7 25 59" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/fa993515-d7c6-40fa-b0af-d7d5f77121e4">

- ex) 1000 | 0110의 값
  - 모두 0인 부분을 빼고 1이 되므로 1110(2)이 됨

# <<(왼쪽 시프트), >>(오른쪽 시프트)
- 왼쪽 시프트(<<) : 비트를 왼쪽으로 옮기는 연산자
  - a << b는 a라는 비트를 b만큼 왼쪽으로 옮긴다는 의미
- 아래 그림은 value << 1을 한 모습
![1](https://github.com/ajhwan/Algorithm_study/assets/129160008/0e9b3de0-4753-4128-b10f-b774d8cbc866)

- ex) 111(2) 7을 << 1을 하면 1110(2) 14가 됨
- ex) 111(2) 7을 << 2을 하면 11100(2) 28이 됨
  - 즉 a << b는 a*2^b와도 같은 의미를 가짐
- 비트마스킹할 때는 (1 << value)꼴로 많이 사용
  - 1 << 3을 하면 1000(2), 8
  - 1 << 4를 하면 10000(2), 16

- 오른쪽 시프트(>>) : 비트를 오른쪽으로 옮기는 것
  - a >> b는 a라는 비트를 b만큼 오른쪽으로 옮긴다는 의미
- 아래 그림은 오른쪽으로 1만큼 옮긴 모습
![2560px-Rotate_right_logically svg](https://github.com/ajhwan/Algorithm_study/assets/129160008/d6b81bf9-1941-4411-b14c-f1b5b04fe511)

- 101(2) 5를 >> 1을 하면 010(2) 2가 됨
- 1111(2) 15를 >> 2를 하면 0011(2) 3이 됨
 - a >> b는 (int)a*(1/2)^b와 같은 의미를 가짐

# ^(XOR), ~(1의 보수연산자)
- ^(XOR연산자) : true ^ true = false, false ^ false = false 이며 나머지는 다 true를 반환
- 서로 다르면 true(1)를 반환
  - 0 ^ 1 = 1(true), 1 ^ 0 = 1(true)
<img width="359" alt="스크린샷 2023-09-06 오후 7 54 03" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/24b50748-777c-4841-a1cf-925dd1993ad7">

- ex) 1001(2) ^ 1000(2) = 0001(2)
- ex) 1010(10) ^ 1000(2) = 0010(2)

- ~(1의 보수연산자) : 해당 수의 모든 비트를 반전하는 연산자
- ~value = ~(value + 1)이라는 특징이 있음
<img width="297" alt="스크린샷 2023-09-06 오후 7 58 21" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/eebb9ee5-2bb0-441d-8f95-3d36d8b4bd43">

- ex) ~011
  - 사실 011은 00000000, 00000000, 00000000, 00000011이므로 비트를 뒤집으면 11111111, 11111111, 11111111, 11111100이 됨

## 비트연사자의 음수표기
- 음수를 표현할 때는 2의 보수법을 이용
  - 해당 양수의 모든 비트를 반전한 수에 1을 더하여 음수를 표현하는 방법
- ex) 16을 이진수로 표현하면
![스크린샷_2023-01-22_오전_10 07 42](https://github.com/ajhwan/Algorithm_study/assets/129160008/4a4c4375-223a-406d-acc3-6b38ab21a0cd)

- 여기서 ~를 통해 비트를 뒤집으면
  - 11111111, 11111111, 11111111, 11101111이되고 여기에 +1을 해서 음수를 표현한 것이 음수표기법
![스크린샷_2023-01-22_오전_10 07 59](https://github.com/ajhwan/Algorithm_study/assets/129160008/ee8064fd-e2ac-4eaa-ad9e-83fe60993aff)

- 즉 ~value = ~value + 1이기 때문에 ~value = ~(value + 1)이 됨

# 인접행렬(adjacency matrix)
- 그래프에서 정점과 간선의 관계를 나타내는 bool타입의 정사각형 행렬을 의미
- 정사각형 행렬의 각 요소가 0 또는 1이라는 값으로 가짐을 의미하며 0은 두 정점 사이의 경로가 없음을 의미하며 1은 두 정점 사이의 경로가 있음을 의미
<img width="342" alt="스크린샷 2023-08-30 오후 10 02 27" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/d893bcaa-1a07-4e0d-9252-355c7ebee617">

- 화살표가 없는 간선을 무방향 간선이라고 하며 무방향 간선은 양방향 간선과 같다고 보면 됨
- 위 그림을 행렬로 표시한다면
<img width="761" alt="스크린샷 2023-08-30 오후 10 04 11" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/f19f6f38-04ee-417c-9a24-01eff1e02f9e">

- 1 - 1, 2 - 2를 보면 0으로 되어있는 것을 볼 수 있는데 자기자신을 나타내는 것이며 해당 정점의 사이클이 없을 때는 0, 사이클이 있을 때는 1로 표기
- 0 - 1 이 연결되어있기 때문에 a[0][1] = 1이 됩니다. 그러나 1 - 3은 연결되어있지 않기 때문에 a[1][3] = 0이 됨
- 위 행렬을 코드로 구현하면
```cpp
bool a[4][4] = {
    {0, 1, 1, 1},
    {1, 0, 1, 0},
    {1, 1, 0, 0},
    {1, 0, 0, 0},
};

bool a[V][V];
for(int i = 0;i < V; i++){
    for(int j = 0; j < V; j++){
        if(a[i][j]){
            //출력하는 로직
            cout << i << "부터 " << j << "까지 경로가 있습니다.\n";
            // 해당 정점으로 부터 탐색하는 로직
            bfs(i);
            dfs(i);
        }
    }
}
```

## 예시문제
> - 3번노드에서 5번노드로 가는 단방향 경로가 있고 이를 인접행렬로 표현한다면?
```cpp
a[3][5] = 1
```
> - 3번노드에서 5번노드로 가는 양뱡향 경로가 있고 이를 인접행렬로 표현한다면?
```cpp
a[3][5] = 1;
a[5][3] = 1;
```
> - 정점의 갯수가 20개인 그래프가 있고, 이를 인접행렬로 표현한다고 하며 메모리를 최소로 쓴다고 했을 때 배열을 어떻게 만들어야 할지?
```cpp
bool a[20][20];
```
> - 정점은 0번부터 9번까지 10개의 노드가 있다. 1 - 2 / 1 - 3 / 3 - 4라는 경로가 있다. (1번과 2번, 1번과 3번, 3번과 4번은 연결되어있다.) 이를 인접행렬로 표현한다면? 
> - 0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수를 만들고 싶다면 어떻게 해야할까? 또한, 정점을 방문하고 다시 방문하지 않게 만드려면 어떻게 해야할까? 
```cpp
#include<bits/stdc++.h>
using namespace std; 
const int V = 10;
bool a[V][V], visited[V];
void go(int from){ 
	visited[from] = 1; 
	cout << from << '\n';
	for(int i = 0; i < V; i++){
		if(visited[i]) continue;
		if(a[from][i]){ 
			go(i);
		}
	}
	return;
}
int main(){
	a[1][2] = 1; a[1][3] = 1; a[3][4] = 1;
	a[2][1] = 1; a[3][1] = 1; a[4][3] = 1;
	for(int i = 0;i < V; i++){
		for(int j = 0; j < V; j++){
			if(a[i][j] && visited[i] == 0){
				go(i); 
			}
		}
	} 
}
```



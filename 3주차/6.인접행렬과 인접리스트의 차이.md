# 공간복잡도
- 인접행렬 : O(V^2)
    - 인접행렬은 vertex가 100라면 x,y(가로, 세로) 각각 100씩 이차원배열을 만들어야 하기 때문
- 인접리스트 : O(V + E)
    - 인접리스트는 정점이 여러개 있더라도 연결된 정점의 간선만 연결리스트에 들어감
```cpp
// 인접행렬
bool adj[V][V];

// 인접리스트
vector<int> adj[V]; 
```

# 시간복잡도 : 간선 한개 찾기
- 인접행렬 : O(1)
- 인접리스트 : O(V)
    - 인접리스트가 모든 정점과 연결되어 있는 경우의 시간복잡도 
```cpp
// 인접행렬
for(int i = 0;i < V; i++){
    for(int j = 0; j < V; j++){
        if(a[i][j]){ 
        }
    }
}

// 인접리스트
for(int j = 0; j < adj[i].size(); j++){
    cout << adj[i][j] << " ";
}
```

# 시간복잡도 : 모든 간선찾기
- 인접행렬 : O(V^2)
    - 모든 2차원배열을 순회
- 인접리스트 :  O(V + E)
    - 만든만큼 걸림
# 결론
- 그래프가 희소할 때는 인접리스트, 조밀 할 때는 인접행렬이 좋음
- 그래프가 희소할 때 (sparse)할 때는 인접행렬이 인접리스트보다 메모리를 더 많이 써야 함
- 간선이 없어서 인접행렬의 대부분의 요소가 0인데도 불구하고 해당 부분을 포함해 2차원 배열을 만들어야 되기 때문
    - 인접리스트는 연결된 정점만 사용하므로 인접리스트가 더 빠르고 좋음
- 그래프가 조밀할 때 (dense)할 때는 인접행렬이 인접리스트보다 더 좋음
- 어차피 다 연결되어있기 때문에 메모리적 효율성은 동일해지고 정점i에서 정점j까지의 간선이 있는 확인하는 속도가 더 빠르기 때문에 인접행렬이 더 빠름

<img width="515" alt="스크린샷 2023-08-31 오후 2 42 33" src="https://github.com/ajhwan/Algorithm_study/assets/129160008/14441868-1172-43d2-84af-665d81e06ae0">

> ## 둘 중 무엇을 쓰면 될까? 
> - 보통 문제에서 sparse한 그래프가 많이 나오기 때문에 인접리스트를 쓰면 됨
> - 다만 문제 또는 코딩인터뷰에서 인접행렬로 주어진다면 그대로 인접행렬로 푸는 것이 좋음
